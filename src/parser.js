// Generated by CoffeeScript 1.6.1
(function() {
  var Log, PSDConstants, Parser, ShapeParser, TextParser, Util;

  PSDConstants = require('./psdconstants');

  Log = require('./log');

  ShapeParser = require('./shapeparser');

  TextParser = require('./textparser');

  Util = require('./util');

  Parser = (function() {

    function Parser() {}

    Parser.parseColor = function(color_object, opacity) {
      var bb, bhex, color_string, gg, ghex, rhex, rr;
      if (opacity == null) {
        opacity = 1.00;
      }
      if (color_object["class"].id === 1380401731) {
        if (parseInt(opacity * 100) === 100) {
          rr = Util.zeroFill(parseInt(color_object.red).toString(16));
          gg = Util.zeroFill(parseInt(color_object.grain).toString(16));
          bb = Util.zeroFill(parseInt(color_object.blue).toString(16));
          color_string = "#" + rr + gg + bb;
        } else {
          rhex = parseInt(color_object.red);
          ghex = parseInt(color_object.grain);
          bhex = parseInt(color_object.blue);
          color_string = "rgba(" + rhex + ", " + ghex + ", " + bhex + ", " + opacity + ")";
        }
        return color_string;
      }
    };

    Parser.parseGradient = function(gradient_object) {
      var color, color_object, color_stops, gradient, gradient_type, location_percentage, opacity_stops, overall_length, transparency_object, _i, _j, _len, _len1, _ref, _ref1;
      gradient_type = PSDConstants.CONSTANTS[gradient_object.type];
      overall_length = gradient_object.gradient.interfaceIconFrameDimmed;
      opacity_stops = {};
      _ref = gradient_object.gradient.transparency;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transparency_object = _ref[_i];
        location_percentage = Math.round((100 * transparency_object.location) / overall_length);
        opacity_stops[location_percentage] = parseFloat(transparency_object.opacity.value / 100).toFixed(2);
      }
      color_stops = [];
      _ref1 = gradient_object.gradient.colors;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        color_object = _ref1[_j];
        location_percentage = Math.round((100 * color_object.location) / overall_length);
        if (opacity_stops[location_percentage] != null) {
          color = this.parseColor(color_object.color, opacity_stops[location_percentage]);
        } else {
          color = this.parseColor(color_object.color);
        }
        color_stops.push("" + color + " " + location_percentage + "%");
      }
      switch (gradient_type) {
        case "linear":
          gradient = {
            type: gradient_type,
            angle: gradient_object.angle.value,
            color_stops: color_stops
          };
          break;
        case "radial":
          gradient = {
            type: gradient_type,
            scale: gradient_object.scale.value,
            color_stops: color_stops
          };
          break;
        default:
          console.log("Unhandled gradient type: " + gradient_type);
      }
      return gradient;
    };

    Parser.parsePattern = function(pattern_object) {
      var pattern;
      pattern = {
        uid: pattern_object.pattern.ID,
        name: pattern_object.pattern.name
      };
      return pattern;
    };

    Parser.parseBorder = function(border_object) {
      var border, opacity;
      opacity = parseFloat(border_object.opacity.value / 100).toFixed(2);
      return border = {
        color: this.parseColor(border_object.color, opacity),
        width: "" + border_object.size.value + "px",
        type: PSDConstants.CONSTANTS[border_object.style]
      };
    };

    Parser.parseShadow = function(shadow_object) {
      var angle, distance, horizontal_offset, opacity, shadow, vertical_offset;
      if (shadow_object == null) {
        return null;
      }
      opacity = parseFloat(shadow_object.opacity.value / 100).toFixed(2);
      distance = shadow_object.distance.value;
      angle = (Math.PI * shadow_object.localLightingAngle.value) / 180;
      horizontal_offset = Math.round(Math.abs(distance * Math.sin(angle)));
      vertical_offset = Math.round(Math.abs(distance * Math.cos(angle)));
      shadow = {
        color: this.parseColor(shadow_object.color, opacity),
        horizontal_offset: "" + horizontal_offset + "px",
        vertical_offset: "" + vertical_offset + "px",
        blur: "" + shadow_object.blur.value + "px",
        spread: "" + shadow_object.noise.value + "px"
      };
      return shadow;
    };

    Parser.parseEffects = function(effects_object) {
      var layer_effect, layer_effects, opacity, parsed_effects, _i, _len;
      layer_effects = Object.keys(effects_object);
      parsed_effects = {};
      if (effects_object.masterFXSwitch === false) {
        return parsed_effects;
      }
      for (_i = 0, _len = layer_effects.length; _i < _len; _i++) {
        layer_effect = layer_effects[_i];
        if (effects_object[layer_effect].enabled === false) {
          continue;
        }
        switch (layer_effect) {
          case "dropShadow":
            if (parsed_effects.shadows == null) {
              parsed_effects.shadows = {};
            }
            parsed_effects.shadows.drop_shadow = this.parseShadow(effects_object['dropShadow']);
            break;
          case "innerShadow":
            if (parsed_effects.shadows == null) {
              parsed_effects.shadows = {};
            }
            parsed_effects.shadows.inner_shadow = this.parseShadow(effects_object['innerShadow']);
            break;
          case "frameFX":
            parsed_effects.border = this.parseBorder(effects_object['frameFX']);
            break;
          case "solidFill":
            opacity = parseFloat(effects_object['solidFill'].opacity.value / 100).toFixed(2);
            parsed_effects.solid_overlay = this.parseColor(effects_object['solidFill'].color, opacity);
            break;
          case "gradientFill":
            parsed_effects.gradient_overlay = this.parseGradient(effects_object['gradientFill']);
            break;
          case "patternFill":
            parsed_effects.pattern_overlay = this.parsePattern(effects_object['patternFill']);
        }
      }
      return parsed_effects;
    };

    Parser.parsePathItem = function(pathItem) {
      var shape;
      shape = new ShapeParser(pathItem.subPathItems);
      shape.parse();
      return shape;
    };

    Parser.parseTextItem = function(textItem, utf16_encoded_str) {
      var text;
      text = new TextParser(textItem, utf16_encoded_str);
      text.parse();
      return text;
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
