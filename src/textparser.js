// Generated by CoffeeScript 1.6.1
(function() {
  var TextParser, Util;

  Util = require('./util');

  TextParser = (function() {

    function TextParser(text_data, utf_encoded_string) {
      var raw_font_set;
      this.text_data = text_data;
      this.utf_encoded_string = utf_encoded_string;
      this.textItem = this.text_data.text.EngineData;
      this.text = this.parseUnicodeEncodedString(utf_encoded_string);
      raw_font_set = this.textItem.DocumentResources.FontSet;
      this.font_set = this.parseFontSet(raw_font_set);
      this.style_sheets = this.textItem.EngineDict.StyleRun.RunArray;
    }

    TextParser.prototype.parse = function() {
      var new_text_object, pos, text_chunk, _i, _j, _ref, _ref1, _results;
      this.parseTransformVector();
      this.parseTextArray();
      this.parseStyleArray();
      this.text_chunks = [];
      for (pos = _i = 0, _ref = this.style_array.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; pos = 0 <= _ref ? ++_i : --_i) {
        text_chunk = {
          styles: this.style_array[pos],
          text: this.text_array[pos]
        };
        this.text_chunks.push(text_chunk);
      }
      if (this.text_chunks.length === 1 || this.text_chunks.length === 0) {
        return;
      }
      _results = [];
      for (pos = _j = _ref1 = this.text_chunks.length - 1; _ref1 <= 1 ? _j <= 1 : _j >= 1; pos = _ref1 <= 1 ? ++_j : --_j) {
        if (TextParser.isSameStyled(this.text_chunks[pos], this.text_chunks[pos - 1])) {
          new_text_object = {
            styles: this.text_chunks[pos].styles,
            text: this.text_chunks[pos - 1].text + this.text_chunks[pos].text
          };
          _results.push(this.text_chunks.splice(pos - 1, 2, new_text_object));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    TextParser.prototype.parseUnicodeEncodedString = function(utf_encoded_string) {
      var first_char, pos, second_char, text, unicode_char, unicode_char_code;
      text = "";
      pos = 1;
      while (pos < this.utf_encoded_string.length - 1) {
        first_char = parseInt(this.utf_encoded_string.charCodeAt(pos)).toString(16);
        second_char = parseInt(this.utf_encoded_string.charCodeAt(pos + 1)).toString(16);
        pos = pos + 2;
        if (second_char === "5c") {
          second_char = parseInt(this.utf_encoded_string.charCodeAt(pos)).toString(16);
          pos = pos + 1;
        }
        unicode_char_code = "0x" + (Util.zeroFill(first_char)) + (Util.zeroFill(second_char));
        unicode_char = String.fromCharCode(unicode_char_code);
        text += unicode_char;
      }
      text = text.substring(0, text.length - 1);
      return text;
    };

    TextParser.prototype.parseTransformVector = function() {
      var transformInfo;
      transformInfo = this.text_data.transformInfo;
      this.multiplication_factor = 1;
      if (transformInfo.xx != null) {
        return this.multiplication_factor *= transformInfo.xx;
      }
    };

    TextParser.prototype.parseTextArray = function() {
      var array_ends, array_starts, i, str, style_lengths_str, value, _i, _j, _k, _ref, _ref1, _ref2, _results;
      style_lengths_str = this.textItem.EngineDict.StyleRun.RunLengthArray;
      value = style_lengths_str.match(/\[(.*)\]/g);
      value = value[0].replace('[', '');
      value = value.replace(']', '');
      this.style_lengths = value.split(' ');
      this.style_lengths.splice(-1);
      for (i = _i = 0, _ref = this.style_lengths.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.style_lengths[i] = parseInt(this.style_lengths[i]);
      }
      this.style_positions = [0];
      for (i = _j = 0, _ref1 = this.style_lengths.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        this.style_positions.push(this.style_lengths[i] + this.style_positions[i]);
      }
      array_starts = this.style_positions.slice(0);
      array_ends = this.style_positions.slice(0);
      array_starts.pop();
      array_ends.shift();
      this.text_array = [];
      _results = [];
      for (i = _k = 0, _ref2 = array_starts.length - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        str = this.text.substring(array_starts[i], array_ends[i]);
        _results.push(this.text_array.push(str));
      }
      return _results;
    };

    TextParser.prototype.parseStyleArray = function() {
      var font_id, font_styles, key, new_font_id, properties, style_sheet, stylesheet_object, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
      this.style_array = [];
      font_id = null;
      _ref = this.style_sheets;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        style_sheet = _ref[_i];
        stylesheet_object = style_sheet.StyleSheet.StyleSheetData;
        new_font_id = stylesheet_object.Font;
        if (new_font_id != null) {
          font_id = new_font_id;
        } else {
          if (font_id == null) {
            font_id = 0;
          }
        }
        properties = {};
        _ref1 = Object.keys(this.font_set[font_id]);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          key = _ref1[_j];
          properties[key] = this.font_set[font_id][key];
        }
        font_styles = this.parseStyleObject(stylesheet_object);
        _ref2 = Object.keys(font_styles);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          key = _ref2[_k];
          properties[key] = font_styles[key];
        }
        _results.push(this.style_array.push(properties));
      }
      return _results;
    };

    TextParser.prototype.parseFontSet = function(raw_font_set) {
      var font, font_name_string, font_properties, font_style, fonts, parts, _i, _len;
      fonts = [];
      for (_i = 0, _len = raw_font_set.length; _i < _len; _i++) {
        font = raw_font_set[_i];
        font_name_string = font.Name;
        parts = font_name_string.split('-');
        font_properties = {};
        font_properties['font-family'] = parts[0];
        if (parts[1] != null) {
          font_style = parts[1];
        }
        switch (font_style) {
          case "Bold":
            font_properties['font-weight'] = "bold";
            break;
          case 'Italic':
          case 'ItalicMT':
          case 'ItalicLT':
          case 'ItalicFF':
          case 'ItalicEF':
            font_properties['font-style'] = "italic";
            break;
          case 'BoldItalic':
          case 'BoldItalicMT':
          case 'BoldItalicLT':
          case 'BoldItalicFF':
          case 'BoldItalicEF':
            font_properties['font-weight'] = "bold";
            font_properties['font-style'] = "italic";
            break;
          case 'BoldIt':
          case 'BoldItMT':
          case 'BoldItLT':
          case 'BoldItFF':
          case 'BoldItEF':
            font_properties['font-weight'] = "bold";
            font_properties['font-style'] = "italic";
            break;
          case 'SemiBoldItalic':
          case 'SemiBoldItalicMT':
          case 'SemiBoldItalicLT':
          case 'SemiBoldItalicFF':
          case 'SemiBoldItalicEF':
            font_properties['font-weight'] = 600;
            font_properties['font-style'] = "italic";
            break;
          case 'Regular':
          case 'RegularMT':
          case 'RegularLT':
          case 'RegularFF':
          case 'RegularEF':
            font_properties['font-weight'] = "normal";
            break;
          case 'Medium':
          case 'MediumMT':
          case 'MediumLT':
          case 'MediumFF':
          case 'MediumFE':
            font_properties['font-weight'] = 600;
        }
        fonts.push(font_properties);
      }
      return fonts;
    };

    TextParser.prototype.parseStyleObject = function(style_object) {
      var font_size, styles;
      styles = {};
      if (style_object.FillColor != null) {
        styles['color'] = this.parseTextColor(style_object.FillColor);
      }
      font_size = parseFloat(style_object.FontSize) * this.multiplication_factor;
      styles['font-size'] = "" + (Math.round(font_size)) + "px";
      if (style_object.FontCaps === 1) {
        styles['font-variant'] = 'small-caps';
      } else if (style_object.FontCaps === 2) {
        styles['text-transform'] = 'uppercase';
      }
      if (style_object.FauxItalic === true) {
        styles['font-style'] = "italic";
      }
      if (style_object.FauxBold === true) {
        styles['font-style'] === "bold";
      }
      if (style_object.Underline === true) {
        styles['text-decoration'] = "underline";
      } else if (style_object.Strikethrough === true) {
        styles['text-decoration'] = "line-through";
      }
      if (style_object.FontBaseline === 0) {
        styles['vertical-align'] === "super";
      } else if (style_object.FontBaseline === 2) {
        styles['vertical-align'] === "bottom";
      }
      return styles;
    };

    TextParser.prototype.parseTextColor = function(color) {
      var bb, bhex, blue, color_arr_str, color_string, gg, ghex, grain, opacity, parts, red, rhex, rr, value;
      color_arr_str = color.Values.match(/\[(.*)\]/g);
      value = color_arr_str[0];
      value = value.replace('[', '');
      value = value.replace(']', '');
      parts = value.split(' ');
      opacity = parseFloat(parts[0]);
      red = Math.round(parseFloat(parts[1]) * 255);
      grain = Math.round(parseFloat(parts[2]) * 255);
      blue = Math.round(parseFloat(parts[3]) * 255);
      if (parseInt(opacity * 100) === 100 || parseInt(opacity * 100) === 0) {
        rr = Util.zeroFill(parseInt(red).toString(16));
        gg = Util.zeroFill(parseInt(grain).toString(16));
        bb = Util.zeroFill(parseInt(blue).toString(16));
        color_string = "#" + rr + gg + bb;
      } else {
        rhex = parseInt(red);
        ghex = parseInt(grain);
        bhex = parseInt(blue);
        color_string = "rgba(" + rhex + ", " + ghex + ", " + bhex + ", " + opacity + ")";
      }
      return color_string;
    };

    TextParser.isSameStyled = function(text_obj_a, text_obj_b) {
      var a_keys, b_keys, key, _i, _len;
      a_keys = Object.keys(text_obj_a.styles).sort();
      b_keys = Object.keys(text_obj_b.styles).sort();
      if (!a_keys === b_keys) {
        return false;
      }
      for (_i = 0, _len = a_keys.length; _i < _len; _i++) {
        key = a_keys[_i];
        if (text_obj_a.styles[key] !== text_obj_b.styles[key]) {
          return false;
        }
      }
      return true;
    };

    TextParser.prototype.toJSON = function() {
      var textItem;
      textItem = {
        full_text: this.text,
        chunks: this.text_chunks
      };
      return textItem;
    };

    return TextParser;

  })();

  module.exports = TextParser;

}).call(this);
