// Generated by CoffeeScript 1.6.1
(function() {
  var Log, PSDBlackWhite, PSDBrightnessContrast, PSDColorBalance, PSDCurves, PSDEffectsInfo, PSDExposure, PSDFillOpacity, PSDGradient, PSDHueSaturation, PSDInvert, PSDLayer, PSDLevels, PSDPath, PSDPattern, PSDPhotoFilter, PSDPosterize, PSDSelectiveColor, PSDSolidColor, PSDThreshold, PSDTypeTool, PSDVibrance, Parser, Util, assert;

  assert = require('./psdassert');

  Log = require('./log');

  Util = require('./util');

  Parser = require('./parser');

  PSDBlackWhite = require('./layerdata/blackwhite');

  PSDBrightnessContrast = require('./layerdata/brightnesscontrast');

  PSDColorBalance = require('./layerdata/colorbalance');

  PSDCurves = require('./layerdata/curves');

  PSDExposure = require('./layerdata/exposure');

  PSDFillOpacity = require('./layerdata/fillopacity');

  PSDGradient = require('./layerdata/gradient');

  PSDHueSaturation = require('./layerdata/huesaturation');

  PSDInvert = require('./layerdata/invert');

  PSDEffectsInfo = require('./layerdata/layereffect');

  PSDLevels = require('./layerdata/levels');

  PSDPattern = require('./layerdata/pattern');

  PSDPosterize = require('./layerdata/posterize');

  PSDPath = require('./layerdata/path');

  PSDPhotoFilter = require('./layerdata/photofilter');

  PSDSelectiveColor = require('./layerdata/selectivecolor');

  PSDSolidColor = require('./layerdata/solidcolor');

  PSDThreshold = require('./layerdata/threshold');

  PSDTypeTool = require('./layerdata/typetool');

  PSDVibrance = require('./layerdata/vibrance');

  PSDLayer = (function() {
    var BLEND_FLAGS, BLEND_MODES, CHANNEL_SUFFIXES, LAYER_TYPES, MASK_FLAGS, SAFE_FONTS, SECTION_DIVIDER_TYPES;

    CHANNEL_SUFFIXES = {
      '-2': 'layer mask',
      '-1': 'A',
      0: 'R',
      1: 'G',
      2: 'B',
      3: 'RGB',
      4: 'CMYK',
      5: 'HSL',
      6: 'HSB',
      9: 'Lab',
      11: 'RGB',
      12: 'Lab',
      13: 'CMYK'
    };

    SECTION_DIVIDER_TYPES = {
      0: "other",
      1: "open folder",
      2: "closed folder",
      3: "bounding section divider"
    };

    BLEND_MODES = {
      "norm": "normal",
      "dark": "darken",
      "lite": "lighten",
      "hue": "hue",
      "sat": "saturation",
      "colr": "color",
      "lum": "luminosity",
      "mul": "multiply",
      "scrn": "screen",
      "diss": "dissolve",
      "over": "overlay",
      "hLit": "hard light",
      "sLit": "soft light",
      "diff": "difference",
      "smud": "exclusion",
      "div": "color dodge",
      "idiv": "color burn",
      "lbrn": "linear burn",
      "lddg": "linear dodge",
      "vLit": "vivid light",
      "lLit": "linear light",
      "pLit": "pin light",
      "hMix": "hard mix"
    };

    BLEND_FLAGS = {
      0: "transparency protected",
      1: "visible",
      2: "obsolete",
      3: "bit 4 useful",
      4: "pixel data irrelevant"
    };

    MASK_FLAGS = {
      0: "position relative",
      1: "layer mask disabled",
      2: "invert layer mask"
    };

    SAFE_FONTS = ["Arial", "Courier New", "Georgia", "Times New Roman", "Verdana", "Trebuchet MS", "Lucida Sans", "Tahoma"];

    LAYER_TYPES = {
      TEXT: "text",
      SHAPE: "shape",
      NORMAL: "normal"
    };

    function PSDLayer(file, header) {
      this.file = file;
      this.header = header != null ? header : null;
      this.image = null;
      this.mask = {};
      this.blendingRanges = {};
      this.adjustments = {};
      this.effects = {};
      this.path_items = {};
      this.text_item = {};
      this.layerType = "normal";
      this.blendingMode = "normal";
      this.opacity = 255;
      this.isFolder = false;
      this.isHidden = false;
    }

    PSDLayer.prototype.parse = function(layerIndex) {
      var bounds, extra_data_start_pos, extralen, extrastart, result;
      if (layerIndex == null) {
        layerIndex = null;
      }
      this.parseInfo(layerIndex);
      this.parseBlendModes();
      extralen = this.file.readInt();
      this.layerEnd = this.file.tell() + extralen;
      assert(extralen > 0);
      extrastart = this.file.tell();
      result = this.parseMaskData();
      if (!result) {
        Log.debug("Error parsing mask data for layer #" + layerIndex + ". Skipping.");
        return this.file.seek(this.layerEnd, false);
      }
      this.parseBlendingRanges();
      this.parseLegacyLayerName();
      extra_data_start_pos = this.file.tell();
      this.parseExtraData();
      if (this.top === 0 && this.bottom === 0 && this.left === 0 && this.right === 0) {
        if (this.pathItems != null) {
          bounds = this.pathItems[0].bounds;
          this.top = bounds.top;
          this.bottom = bounds.bottom;
          this.left = bounds.left;
          this.right = bounds.right;
          this.rows = this.bottom - this.top;
          this.cols = this.right - this.left;
        }
      }
      Log.debug("Layer " + layerIndex + ":", this);
      return this.file.seek(extrastart + extralen, false);
    };

    PSDLayer.prototype.parseInfo = function(layerIndex) {
      var channelID, channelLength, i, _i, _ref, _ref1, _ref2, _ref3, _results;
      this.idx = layerIndex;
      /*
      Layer Info
      */

      _ref = this.file.readf(">iiiih"), this.top = _ref[0], this.left = _ref[1], this.bottom = _ref[2], this.right = _ref[3], this.channels = _ref[4];
      _ref1 = [this.bottom - this.top, this.right - this.left], this.rows = _ref1[0], this.cols = _ref1[1];
      assert(this.channels > 0);
      this.height = this.rows;
      this.width = this.cols;
      if (this.bottom < this.top || this.right < this.left || this.channels > 64) {
        Log.debug("Somethings not right, attempting to skip layer.");
        this.file.seek(6 * this.channels + 12);
        this.file.skipBlock("layer info: extra data");
        return;
      }
      this.channelsInfo = [];
      _results = [];
      for (i = _i = 0, _ref2 = this.channels; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        _ref3 = this.file.readf(">hi"), channelID = _ref3[0], channelLength = _ref3[1];
        Log.debug("Channel " + i + ": id=" + channelID + ", " + channelLength + " bytes, type=" + CHANNEL_SUFFIXES[channelID]);
        _results.push(this.channelsInfo.push({
          id: channelID,
          length: channelLength
        }));
      }
      return _results;
    };

    PSDLayer.prototype.parseBlendModes = function() {
      var filler, flags, _ref;
      this.blendMode = {};
      _ref = this.file.readf(">4s4sBBBB"), this.blendMode.sig = _ref[0], this.blendMode.key = _ref[1], this.blendMode.opacity = _ref[2], this.blendMode.clipping = _ref[3], flags = _ref[4], filler = _ref[5];
      assert(this.blendMode.sig === "8BIM");
      this.blendMode.key = this.blendMode.key.trim();
      this.blendMode.opacityPercentage = (this.blendMode.opacity * 100) / 255;
      this.blendMode.blender = BLEND_MODES[this.blendMode.key];
      this.blendMode.transparencyProtected = flags & 0x01;
      this.blendMode.visible = (flags & (0x01 << 1)) > 0;
      this.blendMode.visible = 1 - this.blendMode.visible;
      this.blendMode.obsolete = (flags & (0x01 << 2)) > 0;
      if ((flags & (0x01 << 3)) > 0) {
        this.blendMode.pixelDataIrrelevant = (flags & (0x01 << 4)) > 0;
      }
      this.blendingMode = this.blendMode.blender;
      this.opacity = parseInt(this.blendMode.opacityPercentage) / 100;
      this.visible = this.blendMode.visible;
      return Log.debug("Blending mode:", this.blendMode);
    };

    PSDLayer.prototype.parseMaskData = function() {
      var flags, _ref, _ref1, _ref2, _ref3;
      this.mask.size = this.file.readInt();
      assert((_ref = this.mask.size) === 36 || _ref === 20 || _ref === 0);
      if (this.mask.size === 0) {
        return true;
      }
      _ref1 = this.file.readf(">llllBB"), this.mask.top = _ref1[0], this.mask.left = _ref1[1], this.mask.bottom = _ref1[2], this.mask.right = _ref1[3], this.mask.defaultColor = _ref1[4], flags = _ref1[5];
      assert((_ref2 = this.mask.defaultColor) === 0 || _ref2 === 255);
      this.mask.width = this.mask.right - this.mask.left;
      this.mask.height = this.mask.bottom - this.mask.top;
      this.mask.relative = flags & 0x01;
      this.mask.disabled = (flags & (0x01 << 1)) > 0;
      this.mask.invert = (flags & (0x01 << 2)) > 0;
      if (this.mask.size === 20) {
        this.file.seek(2);
      } else {
        _ref3 = this.file.readf(">BB"), flags = _ref3[0], this.mask.defaultColor = _ref3[1];
        this.mask.relative = flags & 0x01;
        this.mask.disabled = (flags & (0x01 << 1)) > 0;
        this.mask.invert = (flags & (0x01 << 2)) > 0;
        this.file.seek(16);
      }
      return true;
    };

    PSDLayer.prototype.parseBlendingRanges = function() {
      var i, length, pos, _i, _ref, _results;
      length = this.file.readInt();
      if (length === 0) {
        return;
      }
      this.blendingRanges.grey = {
        source: {
          black: this.file.readShortInt(),
          white: this.file.readShortInt()
        },
        dest: {
          black: this.file.readShortInt(),
          white: this.file.readShortInt()
        }
      };
      pos = this.file.tell();
      this.blendingRanges.numChannels = (length - 8) / 8;
      assert(this.blendingRanges.numChannels > 0);
      this.blendingRanges.channels = [];
      _results = [];
      for (i = _i = 0, _ref = this.blendingRanges.numChannels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.blendingRanges.channels.push({
          source: {
            black: this.file.readShortInt(),
            white: this.file.readShortInt()
          },
          dest: {
            black: this.file.readShortInt(),
            white: this.file.readShortInt()
          }
        }));
      }
      return _results;
    };

    PSDLayer.prototype.parseLegacyLayerName = function() {
      var namelen;
      namelen = Util.pad4(this.file.read(1)[0]);
      this.legacyName = Util.decodeMacroman(this.file.read(namelen)).replace(/\u0000/g, '');
      if (this.name == null) {
        return this.name = this.legacyName;
      }
    };

    PSDLayer.prototype.parseExtraData = function() {
      var fillOpacityPercentage, key, legacyEffects, length, pos, signature, _ref, _results;
      _results = [];
      while (this.file.tell() < this.layerEnd) {
        _ref = this.file.readf(">4s4s"), signature = _ref[0], key = _ref[1];
        assert.equal(signature, "8BIM");
        length = Util.pad2(this.file.readInt());
        pos = this.file.tell();
        Log.debug("Extra layer info: key = " + key + ", length = " + length);
        switch (key) {
          case "SoCo":
            this.adjustments.solid_fill = (new PSDSolidColor(this, length)).parse();
            break;
          case "GdFl":
            this.adjustments.gradient_fill = (new PSDGradient(this, length)).parse();
            break;
          case "PtFl":
            this.adjustments.pattern_fill = (new PSDPattern(this, length)).parse();
            break;
          case "tySh":
            this.textItem = (new PSDTypeTool(this, length)).parse(true);
            break;
          case "TySh":
            this.textItem = (new PSDTypeTool(this, length)).parse();
            break;
          case "lrFX":
            legacyEffects = (new PSDEffectsInfo(this, length)).parseLegacy();
            this.file.read(2);
            break;
          case "lfx2":
            this.effects = (new PSDEffectsInfo(this, length)).parse();
            break;
          case "vmsk":
            this.pathItems = (new PSDPath(this, length)).parse();
            break;
          case "lyid":
            this.layerId = this.file.readInt();
            break;
          case "lsct":
            this.readLayerSectionDivider();
            break;
          case "iOpa":
            fillOpacityPercentage = (new PSDFillOpacity(this, length)).parse();
            this.opacity = parseInt((this.opacity * fillOpacityPercentage) / 100);
            break;
          default:
            this.file.seek(length);
            Log.debug("Skipping additional layer info with key " + key);
        }
        if (this.file.tell() !== (pos + length)) {
          Log.debug("Warning: additional layer info with key " + key + " - unexpected end. Position = " + (this.file.tell()) + ", Expected = " + (pos + length));
          _results.push(this.file.seek(pos + length, false));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    PSDLayer.prototype.readLayerSectionDivider = function() {
      var code;
      code = this.file.readInt();
      this.layerType = SECTION_DIVIDER_TYPES[code];
      Log.debug("Layer type:", this.layerType);
      switch (code) {
        case 1:
        case 2:
          return this.isFolder = true;
        case 3:
          return this.isHidden = true;
      }
    };

    PSDLayer.prototype.toJSON = function() {
      var data, effect, style, styles, _i, _j, _len, _len1, _ref, _ref1;
      data = {};
      data.uid = this.layerId;
      data.name = this.name;
      data.height = this.rows;
      data.width = this.cols;
      data.zindex = this.idx;
      data.idx = this.idx + 1;
      if (this.fillOpacityPercentage != null) {
        data.opacity = parseInt((this.opacity * this.fillOpacityPercentage) / 100);
      } else {
        data.opacity = this.opacity;
      }
      data.bounds = {
        'top': this.top,
        'bottom': this.bottom,
        'left': this.left,
        'right': this.right
      };
      data.type = LAYER_TYPES.NORMAL;
      if (this.blendMode.clipping === 0) {
        data.clipping = false;
      } else {
        data.clipping = true;
      }
      if (this.textItem != null) {
        data.text = this.textItem;
        data.type = LAYER_TYPES.TEXT;
      } else if (this.pathItems != null) {
        if (this.pathItems.length === 1) {
          if (this.pathItems[0].type !== "GENERIC") {
            data.type = LAYER_TYPES.SHAPE;
            data.shape = this.pathItems[0];
          } else {
            data.type = LAYER_TYPES.NORMAL;
            data.shapes = this.pathItems;
          }
        } else {
          data.type = LAYER_TYPES.NORMAL;
          data.shapes = this.pathItems;
        }
      } else {
        data.type = LAYER_TYPES.NORMAL;
      }
      styles = {};
      if (this.adjustments != null) {
        _ref = Object.keys(this.adjustments);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          style = _ref[_i];
          if (style === "solid_fill") {
            styles[style] = Parser.parseColor(this.adjustments[style], this.opacity);
          } else {
            styles[style] = this.adjustments[style];
          }
        }
      }
      if (this.effects != null) {
        _ref1 = Object.keys(this.effects);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          effect = _ref1[_j];
          styles[effect] = this.effects[effect];
        }
      }
      if (data.type === LAYER_TYPES.NORMAL) {
        data.styles = {};
      } else {
        data.styles = styles;
      }
      return data;
    };

    return PSDLayer;

  })();

  module.exports = PSDLayer;

}).call(this);
