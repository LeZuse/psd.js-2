// Generated by CoffeeScript 1.6.1
(function() {
  var Log, PSDColor, PSDImage, Util, fs;

  fs = require('fs');

  Log = require('./log');

  Util = require('./util');

  PSDColor = require('./psdcolor');

  PSDImage = (function() {
    var COMPRESSIONS;

    COMPRESSIONS = {
      0: 'Raw',
      1: 'RLE',
      2: 'ZIP',
      3: 'ZIPPrediction'
    };

    PSDImage.prototype.channelsInfo = [
      {
        id: 0
      }, {
        id: 1
      }, {
        id: 2
      }, {
        id: -1
      }
    ];

    function PSDImage(file, header) {
      this.file = file;
      this.header = header;
      this.numPixels = this.getImageWidth() * this.getImageHeight();
      if (this.getImageDepth() === 16) {
        this.numPixels *= 2;
      }
      this.calculateLength();
      this.channelData = new Uint8Array(this.length);
      this.startPos = this.file.tell();
      this.endPos = this.startPos + this.length;
      this.pixelData = [];
    }

    PSDImage.prototype.calculateLength = function() {
      this.length = (function() {
        switch (this.getImageDepth()) {
          case 1:
            return (this.getImageWidth() + 7) / 8 * this.getImageHeight();
          case 16:
            return this.getImageWidth() * this.getImageHeight() * 2;
          default:
            return this.getImageWidth() * this.getImageHeight();
        }
      }).call(this);
      this.channelLength = this.length;
      return this.length *= this.getImageChannels();
    };

    PSDImage.prototype.parse = function() {
      var _ref;
      this.compression = this.parseCompression();
      Log.debug("Image size: " + this.length + " (" + (this.getImageWidth()) + "x" + (this.getImageHeight()) + ")");
      if ((_ref = this.compression) === 2 || _ref === 3) {
        Log.debug("ZIP compression not implemented yet, skipping.");
        return this.file.seek(this.endPos, false);
      }
      return this.parseImageData();
    };

    PSDImage.prototype.skip = function() {
      Log.debug("Skipping image data");
      return this.file.seek(this.length);
    };

    PSDImage.prototype.parseCompression = function() {
      return this.file.readShortInt();
    };

    PSDImage.prototype.parseImageData = function() {
      Log.debug("Image compression: id=" + this.compression + ", name=" + COMPRESSIONS[this.compression]);
      switch (this.compression) {
        case 0:
          this.parseRaw();
          break;
        case 1:
          this.parseRLE();
          break;
        case 2:
        case 3:
          this.parseZip();
          break;
        default:
          Log.debug("Unknown image compression. Attempting to skip.");
          return this.file.seek(this.endPos, false);
      }
      return this.processImageData();
    };

    PSDImage.prototype.parseRaw = function(length) {
      var i, _i;
      if (length == null) {
        length = this.length;
      }
      Log.debug("Attempting to parse RAW encoded image...");
      for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
        this.channelData[i] = this.file.read(1)[0];
      }
      return true;
    };

    PSDImage.prototype.parseRLE = function() {
      Log.debug("Attempting to parse RLE encoded image...");
      this.byteCounts = this.getByteCounts();
      Log.debug("Read byte counts. Current pos = " + (this.file.tell()) + ", Pixels = " + this.length);
      return this.parseChannelData();
    };

    PSDImage.prototype.getImageHeight = function() {
      return this.header.rows;
    };

    PSDImage.prototype.getImageWidth = function() {
      return this.header.cols;
    };

    PSDImage.prototype.getImageChannels = function() {
      return this.header.channels;
    };

    PSDImage.prototype.getImageDepth = function() {
      return this.header.depth;
    };

    PSDImage.prototype.getByteCounts = function() {
      var byteCounts, i, j, _i, _j, _ref, _ref1;
      byteCounts = [];
      for (i = _i = 0, _ref = this.getImageChannels(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = this.getImageHeight(); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          byteCounts.push(this.file.readShortInt());
        }
      }
      return byteCounts;
    };

    PSDImage.prototype.parseChannelData = function() {
      var chanPos, i, lineIndex, _i, _ref, _ref1;
      chanPos = 0;
      lineIndex = 0;
      for (i = _i = 0, _ref = this.getImageChannels(); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        Log.debug("Parsing channel #" + i + ", Start = " + (this.file.tell()));
        _ref1 = this.decodeRLEChannel(chanPos, lineIndex), chanPos = _ref1[0], lineIndex = _ref1[1];
      }
      return true;
    };

    PSDImage.prototype.decodeRLEChannel = function(chanPos, lineIndex) {
      var byteCount, data, dataIndex, j, k, len, start, val, z, _i, _j, _k, _l, _ref, _ref1, _ref2;
      for (j = _i = 0, _ref = this.getImageHeight(); 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        byteCount = this.byteCounts[lineIndex++];
        start = this.file.tell();
        while (this.file.tell() < start + byteCount) {
          len = this.file.read(1)[0];
          if (len < 128) {
            len++;
            data = this.file.read(len);
            dataIndex = 0;
            for (k = _j = chanPos, _ref1 = chanPos + len; chanPos <= _ref1 ? _j < _ref1 : _j > _ref1; k = chanPos <= _ref1 ? ++_j : --_j) {
              this.channelData[k] = data[dataIndex++];
            }
            chanPos += len;
          } else if (len > 128) {
            len ^= 0xff;
            len += 2;
            val = this.file.read(1)[0];
            data = [];
            for (z = _k = 0; 0 <= len ? _k < len : _k > len; z = 0 <= len ? ++_k : --_k) {
              data.push(val);
            }
            dataIndex = 0;
            for (k = _l = chanPos, _ref2 = chanPos + len; chanPos <= _ref2 ? _l < _ref2 : _l > _ref2; k = chanPos <= _ref2 ? ++_l : --_l) {
              this.channelData[k] = data[dataIndex++];
            }
            chanPos += len;
          }
        }
      }
      return [chanPos, lineIndex];
    };

    PSDImage.prototype.parseZip = function(prediction) {
      if (prediction == null) {
        prediction = false;
      }
      return this.file.seek(this.endPos, false);
    };

    PSDImage.prototype.processImageData = function() {
      Log.debug("Processing parsed image data. " + this.channelData.length + " pixels read.");
      switch (this.header.mode) {
        case 1:
          if (this.getImageDepth() === 8) {
            this.combineGreyscale8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineGreyscale16Channel();
          }
          break;
        case 3:
          if (this.getImageDepth() === 8) {
            this.combineRGB8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineRGB16Channel();
          }
          break;
        case 4:
          if (this.getImageDepth() === 8) {
            this.combineCMYK8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineCMYK16Channel();
          }
          break;
        case 7:
          this.combineMultiChannel8();
          break;
        case 9:
          if (this.getImageDepth() === 8) {
            this.combineLAB8Channel();
          }
          if (this.getImageDepth() === 16) {
            this.combineLAB16Channel();
          }
      }
      return delete this.channelData;
    };

    PSDImage.prototype.getAlphaValue = function(alpha) {
      if (alpha == null) {
        alpha = 255;
      }
      if (this.layer != null) {
        alpha = alpha * (this.layer.blendMode.opacity / 255);
      }
      return alpha;
    };

    PSDImage.prototype.combineGreyscale8Channel = function() {
      var alpha, grey, i, _i, _j, _ref, _ref1, _results, _results1;
      if (this.getImageChannels() === 2) {
        _results = [];
        for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          alpha = this.channelData[i];
          grey = this.channelData[this.channelLength + i];
          _results.push(this.pixelData.push(grey, grey, grey, this.getAlphaValue(alpha)));
        }
        return _results;
      } else {
        _results1 = [];
        for (i = _j = 0, _ref1 = this.numPixels; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(this.pixelData.push(this.channelData[i], this.channelData[i], this.channelData[i], this.getAlphaValue()));
        }
        return _results1;
      }
    };

    PSDImage.prototype.combineGreyscale16Channel = function() {
      var alpha, grey, i, pixel, _i, _j, _ref, _ref1, _results, _results1;
      if (this.getImageChannels() === 2) {
        _results = [];
        for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
          alpha = Util.toUInt16(this.channelData[i + 1], this.channelData[i]);
          grey = Util.toUInt16(this.channelData[this.channelLength + i + 1], this.channelData[this.channelLength + i]);
          _results.push(this.pixelData.push(grey, grey, grey, this.getAlphaValue(alpha)));
        }
        return _results;
      } else {
        _results1 = [];
        for (i = _j = 0, _ref1 = this.numPixels; _j < _ref1; i = _j += 2) {
          pixel = Util.toUInt16(this.channelData[i + 1], this.channelData[i]);
          _results1.push(this.pixelData.push(pixel, pixel, pixel, this.getAlphaValue()));
        }
        return _results1;
      }
    };

    PSDImage.prototype.combineRGB8Channel = function() {
      var chan, i, index, pixel, _i, _j, _len, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        index = 0;
        pixel = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
        _ref1 = this.channelsInfo;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          chan = _ref1[_j];
          switch (chan.id) {
            case -1:
              if (this.getImageChannels() === 4) {
                pixel.a = this.channelData[i + (this.channelLength * index)];
              } else {
                continue;
              }
              break;
            case 0:
              pixel.r = this.channelData[i + (this.channelLength * index)];
              break;
            case 1:
              pixel.g = this.channelData[i + (this.channelLength * index)];
              break;
            case 2:
              pixel.b = this.channelData[i + (this.channelLength * index)];
          }
          index++;
        }
        _results.push(this.pixelData.push(pixel.r, pixel.g, pixel.b, this.getAlphaValue(pixel.a)));
      }
      return _results;
    };

    PSDImage.prototype.combineRGB16Channel = function() {
      var b1, b2, chan, i, index, pixel, _i, _j, _len, _ref, _ref1, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
        index = 0;
        pixel = {
          r: 0,
          g: 0,
          b: 0,
          a: 255
        };
        _ref1 = this.channelsInfo;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          chan = _ref1[_j];
          b1 = this.channelData[i + (this.channelLength * index) + 1];
          b2 = this.channelData[i + (this.channelLength * index)];
          switch (chan.id) {
            case -1:
              if (this.getImageChannels() === 4) {
                pixel.a = Util.toUInt16(b1, b2);
              } else {
                continue;
              }
              break;
            case 0:
              pixel.r = Util.toUInt16(b1, b2);
              break;
            case 1:
              pixel.g = Util.toUInt16(b1, b2);
              break;
            case 2:
              pixel.b = Util.toUInt16(b1, b2);
          }
          index++;
        }
        _results.push(this.pixelData.push(pixel.r, pixel.g, pixel.b, this.getAlphaValue(pixel.a)));
      }
      return _results;
    };

    PSDImage.prototype.combineCMYK8Channel = function() {
      var a, c, i, k, m, rgb, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.getImageChannels() === 5) {
          a = this.channelData[i];
          c = this.channelData[i + this.channelLength];
          m = this.channelData[i + this.channelLength * 2];
          y = this.channelData[i + this.channelLength * 3];
          k = this.channelData[i + this.channelLength * 4];
        } else {
          a = 255;
          c = this.channelData[i];
          m = this.channelData[i + this.channelLength];
          y = this.channelData[i + this.channelLength * 2];
          k = this.channelData[i + this.channelLength * 3];
        }
        rgb = PSDColor.cmykToRGB(255 - c, 255 - m, 255 - y, 255 - k);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(a)));
      }
      return _results;
    };

    PSDImage.prototype.combineCMYK16Channel = function() {
      var a, c, i, k, m, rgb, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
        if (this.getImageChannels() === 5) {
          a = this.channelData[i];
          c = this.channelData[i + this.channelLength];
          m = this.channelData[i + this.channelLength * 2];
          y = this.channelData[i + this.channelLength * 3];
          k = this.channelData[i + this.channelLength * 3];
        } else {
          a = 255;
          c = this.channelData[i];
          m = this.channelData[i + this.channelLength];
          y = this.channelData[i + this.channelLength * 2];
          k = this.channelData[i + this.channelLength * 3];
        }
        rgb = PSDColor.cmykToRGB(255 - c, 255 - m, 255 - y, 255 - k);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(a)));
      }
      return _results;
    };

    PSDImage.prototype.combineLAB8Channel = function() {
      var a, alpha, b, i, l, rgb, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (this.getImageChannels() === 4) {
          alpha = this.channelData[i];
          l = this.channelData[i + this.channelLength];
          a = this.channelData[i + this.channelLength * 2];
          b = this.channelData[i + this.channelLength * 3];
        } else {
          alpha = 255;
          l = this.channelData[i];
          a = this.channelData[i + this.channelLength];
          b = this.channelData[i + this.channelLength * 2];
        }
        rgb = PSDColor.labToRGB(l * 100 >> 8, a - 128, b - 128);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(alpha)));
      }
      return _results;
    };

    PSDImage.prototype.combineLAB16Channel = function() {
      var a, alpha, b, i, l, rgb, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; _i < _ref; i = _i += 2) {
        if (this.getImageChannels() === 4) {
          alpha = this.channelData[i];
          l = this.channelData[i + this.channelLength];
          a = this.channelData[i + this.channelLength * 2];
          b = this.channelData[i + this.channelLength * 3];
        } else {
          alpha = 255;
          l = this.channelData[i];
          a = this.channelData[i + this.channelLength];
          b = this.channelData[i + this.channelLength * 2];
        }
        rgb = PSDColor.labToRGB(l * 100 >> 8, a - 128, b - 128);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(alpha)));
      }
      return _results;
    };

    PSDImage.prototype.combineMultiChannel8 = function() {
      var c, i, k, m, rgb, y, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = this.numPixels; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = this.channelData[i];
        m = this.channelData[i + this.channelLength];
        y = this.channelData[i + this.channelLength * 2];
        if (this.getImageChannels() === 4) {
          k = this.channelData[i + this.channelLength * 3];
        } else {
          k = 255;
        }
        rgb = PSDColor.cmykToRGB(255 - c, 255 - m, 255 - y, 255 - k);
        _results.push(this.pixelData.push(rgb.r, rgb.g, rgb.b, this.getAlphaValue(255)));
      }
      return _results;
    };

    PSDImage.prototype.toCanvasPixels = function() {
      return this.pixelData;
    };

    PSDImage.prototype.toFile = function(filename, cb) {
      var png;
      if (this.toCanvasPixels().length === 0) {
        return cb();
      }
      png = this.getPng();
      if (png === null) {
        return cb();
      }
      return png.encode(function(image) {
        return fs.writeFile(filename, image, cb);
      });
    };

    PSDImage.prototype.toFileSync = function(filename) {
      var image, png;
      if (this.toCanvasPixels().length === 0) {
        return;
      }
      png = this.getPng();
      if (png === null) {
        return;
      }
      image = png.encodeSync();
      return fs.writeFileSync(filename, image);
    };

    PSDImage.prototype.getPng = function() {
      var Png, buffer, i, pixelData, _i, _ref;
      try {
        Png = require('png').Png;
      } catch (e) {
        throw "Exporting PSDs to file requires the node-png library";
      }
      buffer = new Buffer(this.toCanvasPixels().length);
      pixelData = this.toCanvasPixels();
      for (i = _i = 0, _ref = pixelData.length; _i < _ref; i = _i += 4) {
        buffer[i] = pixelData[i];
        buffer[i + 1] = pixelData[i + 1];
        buffer[i + 2] = pixelData[i + 2];
        buffer[i + 3] = 255 - pixelData[i + 3];
      }
      try {
        if (this.getImageWidth() !== 0 && this.getImageHeight() !== 0) {
          return new Png(buffer, this.getImageWidth(), this.getImageHeight(), 'rgba');
        } else {
          return new Png(buffer, this.header.cols, this.header.rows, 'rgba');
        }
      } catch (e) {
        Log.debug(e);
        return null;
      }
    };

    PSDImage.prototype.toCanvas = function(canvas, width, height) {
      var context, i, imageData, pixelData, pxl, _i, _len, _ref;
      if (width == null) {
        width = this.getImageWidth();
      }
      if (height == null) {
        height = this.getImageHeight();
      }
      if ((width == null) || (height == null) || width <= 0 || height <= 0) {
        throw "Layer does not contain image data";
      }
      canvas.width = width;
      canvas.height = height;
      context = canvas.getContext('2d');
      imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      pixelData = imageData.data;
      _ref = this.toCanvasPixels();
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        pxl = _ref[i];
        pixelData[i] = pxl;
      }
      return context.putImageData(imageData, 0, 0);
    };

    PSDImage.prototype.toImage = function() {
      var canvas;
      canvas = document.createElement('canvas');
      this.toCanvas(canvas);
      return canvas.toDataURL("image/png");
    };

    return PSDImage;

  })();

  module.exports = PSDImage;

}).call(this);
