// Generated by CoffeeScript 1.6.1
(function() {
  var PointRecord, ShapeParser;

  PointRecord = require('./pointrecord');

  ShapeParser = (function() {

    ShapeParser.LINE = "LINE";

    ShapeParser.RECTANGLE = "RECTANGLE";

    ShapeParser.ROUNDED_RECTANGLE = "ROUNDED_RECTANGLE";

    ShapeParser.COMPLEX = "GENERIC";

    function ShapeParser(subPathItems) {
      var item, x_max, x_min, xs, y_max, y_min, ys, _i, _len, _ref;
      this.subPathItems = subPathItems;
      this.type = ShapeParser.COMPLEX;
      switch (this.subPathItems.length) {
        case 2:
          if (this.isLine()) {
            this.type = ShapeParser.LINE;
          }
          break;
        case 4:
          if (this.isRectangle()) {
            this.type = ShapeParser.RECTANGLE;
          }
          break;
        case 6:
          if (this.isRoundedRectangle()) {
            this.type = ShapeParser.ROUNDED_RECTANGLE;
          }
          break;
        case 8:
          if (this.isRoundedRectangle()) {
            this.type = ShapeParser.ROUNDED_RECTANGLE;
          }
      }
      xs = [];
      ys = [];
      _ref = this.subPathItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        item = _ref[_i];
        xs.push(item[0].x, item[1].x, item[2].x);
        ys.push(item[0].y, item[1].y, item[2].y);
      }
      x_min = Math.min.apply(null, xs);
      y_min = Math.min.apply(null, ys);
      x_max = Math.max.apply(null, xs);
      y_max = Math.max.apply(null, ys);
      this.bounds = {
        top: y_min,
        left: x_min,
        bottom: y_max,
        right: x_max
      };
      this.width = "" + (y_max - y_min) + "px";
      this.height = "" + (x_max - x_min) + "px";
    }

    ShapeParser.prototype.parse = function() {
      switch (this.type) {
        case ShapeParser.LINE:
          return this.parseLine();
        case ShapeParser.RECTANGLE:
          return this.parseRectangle();
        case ShapeParser.ROUNDED_RECTANGLE:
          return this.parseRoundedRectangle();
        case ShapeParser.COMPLEX:
          return this.parseGenericShape();
      }
    };

    ShapeParser.prototype.isLine = function() {
      var first_subpath, second_subpath;
      first_subpath = new PointRecord(this.subPathItems[0]);
      second_subpath = new PointRecord(this.subPathItems[1]);
      return first_subpath.isPoint() && second_subpath.isPoint();
    };

    ShapeParser.prototype.isRectangle = function() {
      var first_subpath, fourth_subpath, second_subpath, third_subpath;
      first_subpath = new PointRecord(this.subPathItems[0]);
      second_subpath = new PointRecord(this.subPathItems[1]);
      third_subpath = new PointRecord(this.subPathItems[2]);
      fourth_subpath = new PointRecord(this.subPathItems[3]);
      return first_subpath.isPoint() && second_subpath.isPoint() && third_subpath.isPoint() && fourth_subpath.isPoint();
    };

    ShapeParser.prototype.isEllipse = function() {
      return false;
    };

    ShapeParser.prototype.isRoundedRectangle = function() {
      if (this.subPathItems.length === 6) {
        return this.isSixPointRectangle();
      } else if (this.subPathItems.length === 8) {
        return this.isEightPointRectangle();
      }
    };

    ShapeParser.prototype.isSixPointRectangle = function() {
      var current_index, current_item, flag1, flag2, flag3, prev_index, previous_item, _i, _ref;
      for (current_index = _i = 1, _ref = this.subPathItems.length; 1 <= _ref ? _i <= _ref : _i >= _ref; current_index = 1 <= _ref ? ++_i : --_i) {
        prev_index = current_index - 1;
        current_index = current_index % 6;
        current_item = new PointRecord(this.subPathItems[current_index]);
        previous_item = new PointRecord(this.subPathItems[prev_index]);
        flag1 = previous_item.isCurvedBoth() && current_item.isCurvedRightOnly();
        flag2 = previous_item.isCurvedRightOnly() && current_item.isCurvedLeftOnly();
        flag3 = previous_item.isCurvedLeftOnly() && current_item.isCurvedBoth();
        if (!(flag1 || flag2 || flag3)) {
          return false;
        }
      }
      return true;
    };

    ShapeParser.prototype.isEightPointRectangle = function() {
      var current_index, current_item, flag1, flag2, flag3, next_index, next_item, prev_index, previous_item, _i, _ref;
      for (current_index = _i = 1, _ref = this.subPathItems.length; 1 <= _ref ? _i <= _ref : _i >= _ref; current_index = 1 <= _ref ? ++_i : --_i) {
        prev_index = current_index - 1;
        current_index = current_index % 8;
        next_index = (current_index + 1) % 8;
        current_item = new PointRecord(this.subPathItems[current_index]);
        previous_item = new PointRecord(this.subPathItems[prev_index]);
        next_item = new PointRecord(this.subPathItems[next_index]);
        flag1 = previous_item.isCurvedRightOnly() && current_item.isCurvedLeftOnly() && next_item.isCurvedRightOnly();
        flag2 = previous_item.isCurvedLeftOnly() && current_item.isCurvedRightOnly() && next_item.isCurvedLeftOnly();
        flag3 = current_item.isPerpendicular(next_item) && current_item.isPerpendicular(previous_item);
        if (!(flag1 || flag2 || flag3)) {
          return false;
        }
      }
      return true;
    };

    ShapeParser.prototype.parseLine = function() {
      var first_point, length, second_point, x_max, x_min, y_max, y_min;
      first_point = (new PointRecord(this.subPathItems[0])).toPoint();
      second_point = (new PointRecord(this.subPathItems[1])).toPoint();
      x_min = Math.min(first_point.x, second_point.x);
      x_max = Math.max(first_point.x, second_point.x);
      y_min = Math.min(first_point.y, second_point.y);
      y_max = Math.max(first_point.y, second_point.y);
      length = Math.sqrt(Math.pow(x_max - x_min, 2) + Math.pow(y_max - y_min, 2));
      return this.shape = {
        type: this.type,
        bounds: this.bounds,
        length: "" + length + "px"
      };
    };

    ShapeParser.prototype.parseRectangle = function() {
      return this.shape = {
        type: this.type,
        bounds: this.bounds,
        width: this.width,
        height: this.height
      };
    };

    ShapeParser.prototype.parseRoundedRectangle = function() {
      var curvature, curvature_points;
      curvature_points = [new PointRecord(this.subPathItems[0]), new PointRecord(this.subPathItems[1])];
      curvature = curvature_points[0].getCurvature() + curvature_points[1].getCurvature();
      return this.shape = {
        type: this.type,
        bounds: this.bounds,
        width: this.width,
        height: this.height,
        curvature: "" + curvature + "px"
      };
    };

    ShapeParser.prototype.parseGenericShape = function() {
      return this.shape = {
        type: this.type,
        bounds: this.bounds,
        width: this.width,
        height: this.height,
        points: this.subPathItems.length
      };
    };

    ShapeParser.prototype.debug = function(subPathItems) {
      var i, path, _i, _j, _len;
      console.log(subPathItems.length);
      for (_i = 0, _len = subPathItems.length; _i < _len; _i++) {
        path = subPathItems[_i];
        for (i = _j = 0; _j <= 2; i = ++_j) {
          console.log("" + path[i].x + ", " + path[i].y);
        }
      }
      return console.log("");
    };

    ShapeParser.prototype.toJSON = function() {
      return this.shape;
    };

    return ShapeParser;

  })();

  module.exports = ShapeParser;

}).call(this);
