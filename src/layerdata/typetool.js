// Generated by CoffeeScript 1.6.1
(function() {
  var Log, PSDDescriptor, PSDTypeTool, Parser, assert;

  PSDDescriptor = require('../psddescriptor');

  Parser = require('../parser');

  assert = require('../psdassert');

  Log = require('../log');

  PSDTypeTool = (function() {

    PSDTypeTool.prototype.engineDataRegex = [
      {
        search: /\\\)/g,
        replace: ""
      }, {
        search: /\u0000/g,
        replace: ""
      }, {
        search: /<</g,
        replace: ' {'
      }, {
        search: />>/g,
        replace: '},'
      }, {
        search: /\(../g,
        replace: '"'
      }, {
        search: /\)/g,
        replace: '"'
      }, {
        search: /.*NoStart.*/g,
        replace: ""
      }, {
        search: /.*NoEnd.*/g,
        replace: ""
      }, {
        search: /.*Keep.*/g,
        replace: ""
      }, {
        search: /.*Hanging.*/g,
        replace: ""
      }, {
        search: /\/(\w+)\s+(\{)\s+/g,
        replace: '"$1": $2\n'
      }, {
        search: /\/(\w+)\s+(\[)\s+/g,
        replace: '"$1": $2'
      }, {
        search: /"(\w+)":\s(\[.*\])\s+/g,
        replace: '"$1": "$2",\n'
      }, {
        search: /\/(\w+)\s+([0-9]+\.[0-9]+|[0-9]+)\s+/g,
        replace: '"$1": $2,\n'
      }, {
        search: /\/(\w+)\s+\.([0-9]+|[0-9]+)\s+/g,
        replace: '"$1": 0.$2,\n'
      }, {
        search: /\/(\w+)\s+([0-9]+)\s+/g,
        replace: '"$1": $2,\n'
      }, {
        search: /\/(\w+)\s+(.*)\s/g,
        replace: '"$1": $2,\n'
      }, {
        search: /\]/g,
        replace: '],'
      }, {
        search: /\,([\t\r\n]*)\}/g,
        replace: '$1}'
      }, {
        search: /\,([\t\r\n]*)\]/g,
        replace: '$1]'
      }
    ];

    function PSDTypeTool(layer, length) {
      this.layer = layer;
      this.length = length;
      this.file = this.layer.file;
      this.data = {};
    }

    PSDTypeTool.prototype.parse = function(legacy) {
      var char, descriptorVersion, engineData, engineJSON, last_pos, match, matches, regex, replacement, textVersion, utf16_encoded_string, version, warpVersion, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      if (legacy == null) {
        legacy = false;
      }
      version = this.file.readShortInt();
      assert(version === 1);
      this.data.transformInfo = {};
      _ref = this.file.readf(">6d"), this.data.transformInfo.xx = _ref[0], this.data.transformInfo.xy = _ref[1], this.data.transformInfo.yx = _ref[2], this.data.transformInfo.yy = _ref[3], this.data.transformInfo.tx = _ref[4], this.data.transformInfo.ty = _ref[5];
      if (legacy) {
        return this.parseLegacy();
      }
      textVersion = this.file.readShortInt();
      assert(textVersion === 50);
      descriptorVersion = this.file.readInt();
      assert(descriptorVersion === 16);
      this.data.text = (new PSDDescriptor(this.file)).parse();
      engineData = "";
      _ref1 = this.data.text.EngineData;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        char = _ref1[_i];
        engineData += String.fromCharCode(char);
      }
      utf16_encoded_string = this.getTextContent(engineData);
      engineData = engineData.replace(/\\\(/g, "");
      engineData = engineData.replace(/\\\)/g, "");
      matches = engineData.match(/\(([^\)]+)\)/g);
      for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
        match = matches[_j];
        replacement = match.replace(/[\n\r]/g, "\\n");
        replacement = replacement.replace(/"/g, "'");
        engineData = engineData.replace(match, replacement);
      }
      _ref2 = this.engineDataRegex;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        regex = _ref2[_k];
        engineData = engineData.replace(regex.search, regex.replace);
      }
      last_pos = engineData.lastIndexOf(',');
      engineData = engineData.substring(0, last_pos);
      try {
        engineJSON = eval('(' + engineData + ')');
        this.data.text.EngineData = engineJSON;
      } catch (err) {
        this.data.text.EngineData = engineData;
        console.log(err);
      }
      Log.debug("Text:", this.data.text);
      warpVersion = this.file.readShortInt();
      assert(warpVersion === 1);
      descriptorVersion = this.file.readInt();
      assert(descriptorVersion === 16);
      this.data.warp = (new PSDDescriptor(this.file)).parse();
      Log.debug("Warp:", this.data.warp);
      _ref3 = this.file.readf(">4d"), this.data.left = _ref3[0], this.data.top = _ref3[1], this.data.right = _ref3[2], this.data.bottom = _ref3[3];
      this.text = Parser.parseTextItem(this.data, utf16_encoded_string);
      return this.text;
    };

    PSDTypeTool.prototype.getTextContent = function(engineData) {
      var text, texts, utf16_encoded_string;
      texts = engineData.match(/\/Text \(\u00FE\u00FF([\s\S]*?)[^\\]\)/g);
      text = texts[0].match(/\([\s\S]*\)/g)[0];
      text = text.replace(/\(\u00FE\u00FF([\s\S]*)[^\\]\)/g, '"$1"');
      utf16_encoded_string = text;
      return utf16_encoded_string;
    };

    PSDTypeTool.prototype.parseLegacy = function() {
      var i, j, version, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      version = this.file.readShortInt();
      assert(version === 6);
      this.data.facesCount = this.file.readShortInt();
      this.data.face = [];
      for (i = _i = 0, _ref = this.data.facesCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data.face[i] = {};
        this.data.face[i].mark = this.file.readShortInt();
        this.data.face[i].fontType = this.file.readInt();
        this.data.face[i].fontName = this.file.readLengthWithString();
        this.data.face[i].fontFamilyName = this.file.readLengthWithString();
        this.data.face[i].fontStyleName = this.file.readLengthWithString();
        this.data.face[i].script = this.file.readShortInt();
        this.data.face[i].numberAxesVector = this.file.readInt();
        this.data.face[i].vector = [];
        for (j = _j = 0, _ref1 = this.data.face[i].numberAxesVector; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.data.face[i].vector[j] = this.file.readInt();
        }
      }
      this.data.stylesCount = this.file.readShortInt();
      this.data.style = [];
      for (i = _k = 0, _ref2 = this.data.stylesCount; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.data.style[i] = {};
        this.data.style[i].mark = this.file.readShortInt();
        this.data.style[i].faceMark = this.file.readShortInt();
        this.data.style[i].size = this.file.readInt();
        this.data.style[i].tracking = this.file.readInt();
        this.data.style[i].kerning = this.file.readInt();
        this.data.style[i].leading = this.file.readInt();
        this.data.style[i].baseShift = this.file.readInt();
        this.data.style[i].autoKern = this.file.readBoolean();
        this.file.read(1);
        this.data.style[i].rotate = this.file.readBoolean();
      }
      this.data.type = this.file.readShortInt();
      this.data.scalingFactor = this.file.readInt();
      this.data.sharacterCount = this.file.readInt();
      this.data.horzPlace = this.file.readInt();
      this.data.vertPlace = this.file.readInt();
      this.data.selectStart = this.file.readInt();
      this.data.selectEnd = this.file.readInt();
      this.data.linesCount = this.file.readShortInt();
      this.data.line = [];
      for (i = _l = 0, _ref3 = this.data.linesCount; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; i = 0 <= _ref3 ? ++_l : --_l) {
        this.data.line[i].charCount = this.file.readInt();
        this.data.line[i].orientation = this.file.readShortInt();
        this.data.line[i].alignment = this.file.readShortInt();
        this.data.line[i].actualChar = this.file.readShortInt();
        this.data.line[i].style = this.file.readShortInt();
      }
      this.data.color = this.file.readSpaceColor();
      this.data.antialias = this.file.readBoolean();
      return this.data;
    };

    return PSDTypeTool;

  })();

  module.exports = PSDTypeTool;

}).call(this);
